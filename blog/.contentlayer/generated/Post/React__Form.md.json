{
  "title": "Form",
  "category": "React",
  "body": {
    "raw": "# React 폼 관리\n\n## 비제어 컴포넌트 (Uncontrolled Components)\n\nuseRef를 사용하여 DOM 요소에 직접 접근하는 방식. 입력값을 React State로 관리하지 않고 제출 시점에 필요한 값을 DOM에서 읽는다.\n\n### 주의사항\n\n- 기본값은 `defaultValue` 속성으로 지정\n- `value` 속성을 사용하면 값이 변경되지 않음\n\n### 언제 쓰나\n\n- **단순 폼**: 즉각적인 유효성 검사/상태 동기화가 중요하지 않을 때\n- **파일 입력**: 파일 인풋은 제어가 불가하여 보통 `ref`로 접근\n- **성능 고려**: 매우 많은 입력이 있을 때 렌더링을 최소화하고 싶을 때\n\n### 예제\n\n```jsx\nimport { useRef } from \"react\";\n\nfunction UncontrolledForm() {\n  const nameRef = useRef(null);\n  const ageRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const name = nameRef.current?.value ?? \"\";\n    const age = Number(ageRef.current?.value ?? 0);\n    alert(`${name} / ${age}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input ref={nameRef} defaultValue=\"홍길동\" placeholder=\"이름\" />\n      <input ref={ageRef} type=\"number\" defaultValue={20} placeholder=\"나이\" />\n      <button type=\"submit\">저장</button>\n    </form>\n  );\n}\n```\n\n### 파일 입력 예제\n\n```jsx\nimport { useRef } from \"react\";\n\nfunction FileInput() {\n  const fileRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const file = fileRef.current?.files?.[0];\n    if (!file) return alert(\"파일을 선택하세요\");\n    console.log(file.name, file.size);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input ref={fileRef} type=\"file\" accept=\"image/*\" />\n      <button type=\"submit\">업로드</button>\n    </form>\n  );\n}\n```\n\n## State 관리\n\n### 스프레드 구문 (얕은 복제)\n\n```javascript\n...value\n```\n\n얕은 복제는 객체/배열의 1단계 프로퍼티만 복제한다. 중첩 객체는 참조가 유지된다.\n\n```jsx\n// 객체 업데이트\nconst [user, setUser] = useState({ name: \"\", age: 0 });\nsetUser((prev) => ({ ...prev, age: prev.age + 1 }));\n\n// 배열 업데이트\nconst [todos, setTodos] = useState([{ id: 1, text: \"a\", done: false }]);\nsetTodos((prev) => prev.map((t) => (t.id === 1 ? { ...t, done: !t.done } : t)));\n```\n\n### 중첩된 State 관리\n\n- 예시: `address { city, do }`와 같은 중첩 구조\n- address 업데이트 시 추가 복제 필요\n- **권장**: State를 평평하게 구성 (State 정규화)\n\n```jsx\n// 중첩 상태를 전개할 때는 단계별로 복제\nconst [profile, setProfile] = useState({\n  name: \"\",\n  address: { city: \"\", do: \"\" },\n});\n\nsetProfile((prev) => ({\n  ...prev,\n  address: { ...prev.address, city: \"서울\" },\n}));\n```\n\n#### 정규화(평평하게 만들기) 예시\n\n```jsx\n// before\nconst [profile, setProfile] = useState({\n  name: \"\",\n  address: { city: \"\", do: \"\" },\n});\n\n// after: 평평한 구조 → 부분 업데이트가 단순해짐\nconst [name, setName] = useState(\"\");\nconst [city, setCity] = useState(\"\");\nconst [do_, setDo] = useState(\"\");\n```\n\n### Immer 라이브러리\n\n불가피하게 중첩된 State를 사용해야 할 때 권장되는 라이브러리. 불변성을 자동으로 유지하며, 직관적인 \"변경 코드\"를 작성할 수 있다.\n\n```bash\nnpm i immer\n```\n\n```jsx\nimport { useState } from \"react\";\nimport { produce } from \"immer\";\n\nfunction Profile() {\n  const [profile, setProfile] = useState({\n    name: \"\",\n    address: { city: \"\", do: \"\" },\n  });\n\n  const updateCity = () => {\n    setProfile((prev) =>\n      produce(prev, (draft) => {\n        draft.address.city = \"서울\";\n      })\n    );\n  };\n\n  return (\n    <div>\n      <div>{profile.address.city}</div>\n      <button onClick={updateCity}>도시 변경</button>\n    </div>\n  );\n}\n```\n\n배열 예제:\n\n```jsx\nconst [todos, setTodos] = useState([\n  { id: 1, text: \"a\", done: false },\n  { id: 2, text: \"b\", done: true },\n]);\n\nconst toggle = (id) => {\n  setTodos((prev) =>\n    produce(prev, (draft) => {\n      const item = draft.find((t) => t.id === id);\n      if (item) item.done = !item.done;\n    })\n  );\n};\n```\n\n### 제어 컴포넌트 (Controlled Components)\n\n입력값을 React State로 완전히 관리하는 방식. `value`와 `onChange`를 통해 UI ↔ 상태를 동기화한다.\n\n#### 장단점\n\n- 장점: 즉각 유효성 검증, 버튼 비활성 같은 UI 제어, 예측 가능한 상태\n- 단점: 입력 수가 매우 많으면 렌더링 비용 증가 가능\n\n#### 예제\n\n```jsx\nimport { useState } from \"react\";\n\nfunction ControlledForm() {\n  const [name, setName] = useState(\"\");\n  const [age, setAge] = useState(\"\");\n\n  const isValid = name.trim().length >= 2 && Number(age) > 0;\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (!isValid) return;\n    console.log({ name, age: Number(age) });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder=\"이름\"\n      />\n      <input\n        value={age}\n        onChange={(e) => setAge(e.target.value)}\n        type=\"number\"\n        placeholder=\"나이\"\n      />\n      <button type=\"submit\" disabled={!isValid}>\n        저장\n      </button>\n    </form>\n  );\n}\n```\n\n### 팁\n\n- 파일 입력은 제어 불가 → `ref` 사용\n- 큰 폼은 하이브리드: 입력은 비제어 + 제출 시 `FormData`로 한 번에 수집\n- 성능이 문제면 `onChange`를 디바운스하거나 `React Hook Form` 같은 라이브러리 고려\n",
    "html": "<h1>React 폼 관리</h1>\n<h2>비제어 컴포넌트 (Uncontrolled Components)</h2>\n<p>useRef를 사용하여 DOM 요소에 직접 접근하는 방식. 입력값을 React State로 관리하지 않고 제출 시점에 필요한 값을 DOM에서 읽는다.</p>\n<h3>주의사항</h3>\n<ul>\n<li>기본값은 <code>defaultValue</code> 속성으로 지정</li>\n<li><code>value</code> 속성을 사용하면 값이 변경되지 않음</li>\n</ul>\n<h3>언제 쓰나</h3>\n<ul>\n<li><strong>단순 폼</strong>: 즉각적인 유효성 검사/상태 동기화가 중요하지 않을 때</li>\n<li><strong>파일 입력</strong>: 파일 인풋은 제어가 불가하여 보통 <code>ref</code>로 접근</li>\n<li><strong>성능 고려</strong>: 매우 많은 입력이 있을 때 렌더링을 최소화하고 싶을 때</li>\n</ul>\n<h3>예제</h3>\n<pre><code class=\"language-jsx\">import { useRef } from \"react\";\n\nfunction UncontrolledForm() {\n  const nameRef = useRef(null);\n  const ageRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const name = nameRef.current?.value ?? \"\";\n    const age = Number(ageRef.current?.value ?? 0);\n    alert(`${name} / ${age}`);\n  };\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input ref={nameRef} defaultValue=\"홍길동\" placeholder=\"이름\" />\n      &#x3C;input ref={ageRef} type=\"number\" defaultValue={20} placeholder=\"나이\" />\n      &#x3C;button type=\"submit\">저장&#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<h3>파일 입력 예제</h3>\n<pre><code class=\"language-jsx\">import { useRef } from \"react\";\n\nfunction FileInput() {\n  const fileRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const file = fileRef.current?.files?.[0];\n    if (!file) return alert(\"파일을 선택하세요\");\n    console.log(file.name, file.size);\n  };\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input ref={fileRef} type=\"file\" accept=\"image/*\" />\n      &#x3C;button type=\"submit\">업로드&#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<h2>State 관리</h2>\n<h3>스프레드 구문 (얕은 복제)</h3>\n<pre><code class=\"language-javascript\">...value\n</code></pre>\n<p>얕은 복제는 객체/배열의 1단계 프로퍼티만 복제한다. 중첩 객체는 참조가 유지된다.</p>\n<pre><code class=\"language-jsx\">// 객체 업데이트\nconst [user, setUser] = useState({ name: \"\", age: 0 });\nsetUser((prev) => ({ ...prev, age: prev.age + 1 }));\n\n// 배열 업데이트\nconst [todos, setTodos] = useState([{ id: 1, text: \"a\", done: false }]);\nsetTodos((prev) => prev.map((t) => (t.id === 1 ? { ...t, done: !t.done } : t)));\n</code></pre>\n<h3>중첩된 State 관리</h3>\n<ul>\n<li>예시: <code>address { city, do }</code>와 같은 중첩 구조</li>\n<li>address 업데이트 시 추가 복제 필요</li>\n<li><strong>권장</strong>: State를 평평하게 구성 (State 정규화)</li>\n</ul>\n<pre><code class=\"language-jsx\">// 중첩 상태를 전개할 때는 단계별로 복제\nconst [profile, setProfile] = useState({\n  name: \"\",\n  address: { city: \"\", do: \"\" },\n});\n\nsetProfile((prev) => ({\n  ...prev,\n  address: { ...prev.address, city: \"서울\" },\n}));\n</code></pre>\n<h4>정규화(평평하게 만들기) 예시</h4>\n<pre><code class=\"language-jsx\">// before\nconst [profile, setProfile] = useState({\n  name: \"\",\n  address: { city: \"\", do: \"\" },\n});\n\n// after: 평평한 구조 → 부분 업데이트가 단순해짐\nconst [name, setName] = useState(\"\");\nconst [city, setCity] = useState(\"\");\nconst [do_, setDo] = useState(\"\");\n</code></pre>\n<h3>Immer 라이브러리</h3>\n<p>불가피하게 중첩된 State를 사용해야 할 때 권장되는 라이브러리. 불변성을 자동으로 유지하며, 직관적인 \"변경 코드\"를 작성할 수 있다.</p>\n<pre><code class=\"language-bash\">npm i immer\n</code></pre>\n<pre><code class=\"language-jsx\">import { useState } from \"react\";\nimport { produce } from \"immer\";\n\nfunction Profile() {\n  const [profile, setProfile] = useState({\n    name: \"\",\n    address: { city: \"\", do: \"\" },\n  });\n\n  const updateCity = () => {\n    setProfile((prev) =>\n      produce(prev, (draft) => {\n        draft.address.city = \"서울\";\n      })\n    );\n  };\n\n  return (\n    &#x3C;div>\n      &#x3C;div>{profile.address.city}&#x3C;/div>\n      &#x3C;button onClick={updateCity}>도시 변경&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>배열 예제:</p>\n<pre><code class=\"language-jsx\">const [todos, setTodos] = useState([\n  { id: 1, text: \"a\", done: false },\n  { id: 2, text: \"b\", done: true },\n]);\n\nconst toggle = (id) => {\n  setTodos((prev) =>\n    produce(prev, (draft) => {\n      const item = draft.find((t) => t.id === id);\n      if (item) item.done = !item.done;\n    })\n  );\n};\n</code></pre>\n<h3>제어 컴포넌트 (Controlled Components)</h3>\n<p>입력값을 React State로 완전히 관리하는 방식. <code>value</code>와 <code>onChange</code>를 통해 UI ↔ 상태를 동기화한다.</p>\n<h4>장단점</h4>\n<ul>\n<li>장점: 즉각 유효성 검증, 버튼 비활성 같은 UI 제어, 예측 가능한 상태</li>\n<li>단점: 입력 수가 매우 많으면 렌더링 비용 증가 가능</li>\n</ul>\n<h4>예제</h4>\n<pre><code class=\"language-jsx\">import { useState } from \"react\";\n\nfunction ControlledForm() {\n  const [name, setName] = useState(\"\");\n  const [age, setAge] = useState(\"\");\n\n  const isValid = name.trim().length >= 2 &#x26;&#x26; Number(age) > 0;\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (!isValid) return;\n    console.log({ name, age: Number(age) });\n  };\n\n  return (\n    &#x3C;form onSubmit={handleSubmit}>\n      &#x3C;input\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder=\"이름\"\n      />\n      &#x3C;input\n        value={age}\n        onChange={(e) => setAge(e.target.value)}\n        type=\"number\"\n        placeholder=\"나이\"\n      />\n      &#x3C;button type=\"submit\" disabled={!isValid}>\n        저장\n      &#x3C;/button>\n    &#x3C;/form>\n  );\n}\n</code></pre>\n<h3>팁</h3>\n<ul>\n<li>파일 입력은 제어 불가 → <code>ref</code> 사용</li>\n<li>큰 폼은 하이브리드: 입력은 비제어 + 제출 시 <code>FormData</code>로 한 번에 수집</li>\n<li>성능이 문제면 <code>onChange</code>를 디바운스하거나 <code>React Hook Form</code> 같은 라이브러리 고려</li>\n</ul>"
  },
  "_id": "React/Form.md",
  "_raw": {
    "sourceFilePath": "React/Form.md",
    "sourceFileName": "Form.md",
    "sourceFileDir": "React",
    "contentType": "markdown",
    "flattenedPath": "React/Form"
  },
  "type": "Post",
  "url": "/posts/React/Form",
  "slug": "React/Form",
  "readingTime": 4
}